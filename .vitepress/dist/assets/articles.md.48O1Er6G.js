import{_ as h,C as p,c as a,o as s,j as t,F as i,B as l,t as o,a as c,G as g,w as f,k as y}from"./chunks/framework.Bw-5EFTY.js";const b=JSON.parse('[{"frontmatter":{"id":"1","title":"Bitwise DNA Compression in Rust: Small Footprint with Fast Reverse Complements","categories":["Rust","Data Compression","Systems Programming"],"description":"How I used Rust to compress DNA sequences with 4-bit encodings, enabling fast bitwise rotation-based DNA Complementary base pairs.","date":"2025-06-17","tags":["Rust","Systems Programming","Algorithms","DNA","Compression","Bitwise","Bioinformatics"],"search":true,"listed":true},"excerpt":"<p>DNA datasets are massive. A single human genome can use several gigabytes of storage in its most simplest form of storage. Certain forms of storage can even scale to <a href=\\"https://medium.com/precision-medicine/how-big-is-the-human-genome-e90caa3409b0\\" target=\\"_blank\\" rel=\\"noreferrer\\">200 GB for a single genome alone</a>. As DNA sequencing becomes cheaper, roughly <a href=\\"https://www.genome.gov/about-genomics/fact-sheets/Genomic-Data-Science\\" target=\\"_blank\\" rel=\\"noreferrer\\">40 exabytes of genomic data are produced per year</a>.</p>\\n<p>Efficiently storing and analyzing these sequences is a critical challenge. Furthermore, the ability to analyze large sequences of data are increasingly critical. In this post, we will explore a method to compress DNA using 4-bits per nucleotide in pure Rust, that allows us to generate Complementary base pairs in its compressed form.</p>\\n<p>This technique is especially useful in DNA analytical pipelines, where performance and memory constraints are critical. By minimizing the footprint of each sequence, we simultaneously reduce storage overhead and in-memory costs, without sacrificing speed or the ability to operate directly on compressed data.</p>\\n<h2 id=\\"background\\" tabindex=\\"-1\\">Background <a class=\\"header-anchor\\" href=\\"#background\\" aria-label=\\"Permalink to &quot;Background&quot;\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\"dna-bases-and-iupac-codes\\" tabindex=\\"-1\\">DNA Bases and IUPAC Codes <a class=\\"header-anchor\\" href=\\"#dna-bases-and-iupac-codes\\" aria-label=\\"Permalink to &quot;DNA Bases and IUPAC Codes&quot;\\">&ZeroWidthSpace;</a></h3>\\n<p>There are <a href=\\"ttps://genome.ucsc.edu/goldenPath/help/iupac.html\\" target=\\"_blank\\" rel=\\"noreferrer\\">15 IUPAC codes</a>. The ones that most are familiar with are &quot;A&quot;, &quot;G&quot;, &quot;C&quot;, and &quot;T&quot;, representing the four standard DNA bases. However, DNA sequencing often produces ambiguous results. The remaining 11 codes are for these cases. For example, &quot;R&quot; can represent &quot;G&quot; <em>or</em> &quot;A&quot;, while &quot;N&quot; can represent <em>any</em> nucleotide.</p>\\n<details>\\n<summary>Click to show all 15 IUPAC codes</summary>\\n<p>|  | Symbol | Bases |\\n|</p>\\n","url":"/articles/dna-compression.html"},{"frontmatter":{"id":"2","title":"Simple Key-Value Cache Built in Golang","description":"An append-only log, built with zero dependencies in Golang, and how I integrate it into my workflow with Hammerspoon.","date":"2025-12-08","categories":["Golang","Cache","Automation"],"tags":["Golang","Algorithms","Cache","Hammerspoon"],"listed":true,"draft":false},"excerpt":"","url":"/articles/simple-kv-cache.html"}]'),_={style:{"list-style-type":"none"}},w=["href"],q={style:{"margin-bottom":"16px","font-size":"0.95em"}},A={style:{"margin-bottom":"16px","font-size":"0.875em",color:"#6b7280","font-weight":"600"}},C={class:"tags",style:{"font-size":"0.875em",color:"#6b7280","font-weight":"600"}},D={class:"tags-item"},x=JSON.parse('{"title":"Latest Articles","description":"The archive.","frontmatter":{"title":"Latest Articles","description":"The archive.","hideFrontMeta":true,"sidebar":false},"headers":[],"relativePath":"articles.md","filePath":"articles.md"}'),v={name:"articles.md"},N=Object.assign(v,{setup(k){function m(r){return r?new Date(r).toLocaleDateString("en-UK",{year:"numeric",month:"long",day:"numeric"}):""}return(r,n)=>{const d=p("Badge");return s(),a("div",null,[t("div",_,[(s(!0),a(i,null,l(y(b),e=>(s(),a("li",{key:e.link},[t("a",{href:e.url},[t("h2",null,o(e.frontmatter.title),1)],8,w),t("div",q,o(e.frontmatter.description),1),t("div",A,o(m(e.frontmatter.date)),1),t("div",C,[n[0]||(n[0]=c(" Tags: ")),(s(!0),a(i,null,l(e.frontmatter.tags,u=>(s(),a("span",D,[g(d,null,{default:f(()=>[c(o(u),1)]),_:2},1024)]))),256))])]))),128))])])}}}),S=h(N,[["__scopeId","data-v-5324dfe4"]]);export{x as __pageData,S as default};
